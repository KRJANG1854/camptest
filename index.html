<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no" />
  <title>모바일 지도로 요일 라벨러</title>
  <style>
    :root{
      --bg:#0b0b0f; --panel:#14151a; --muted:#7f8596; --text:#e9ecf1; --accent:#5aa2ff; --danger:#ff6b6b;
      --btn:#1c1f27; --btn2:#202431; --border:#2a3040;
      --map-h: 68dvh;
    }
    html,body{height:100%; overscroll-behavior:none;}
    body{
      margin:0;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Pretendard,Apple SD Gothic Neo,Malgun Gothic,sans-serif;
      -webkit-tap-highlight-color: transparent;
      -webkit-text-size-adjust: 100%;
    }
    .app{display:flex;flex-direction:column;gap:10px;max-width:1000px;margin:0 auto;padding:10px;}
    .toolbar{display:grid;grid-template-columns:1fr;gap:10px;}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px;}
    .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .row label{font-size:14px;color:var(--muted)}
    .btn{appearance:none;border:1px solid var(--border);background:var(--btn);color:var(--text);padding:10px 12px;border-radius:12px;font-size:14px;line-height:1;font-weight:600;cursor:pointer;user-select:none}
    .btn[data-active="true"]{outline:2px solid var(--accent);}
    .btn:active{scale:.98}
    .btn.danger{background:#2a1515;border-color:#3a1c1c;color:#ffdede}
    .btn.ghost{background:transparent}
    .seg{display:inline-flex;background:var(--btn2);border:1px solid var(--border);border-radius:12px;overflow:hidden}
    .seg button{all:unset;padding:10px 12px;cursor:pointer;color:var(--text);font-weight:700}
    .seg button[aria-pressed="true"]{background:var(--accent);color:black}

    .map-wrap{
      position:relative;background:#0a0b0f;border:1px solid var(--border);border-radius:14px;overflow:hidden;
      touch-action:none; -webkit-user-select:none; user-select:none;
      height:var(--map-h); height:68vh;
    }
    .map-stage{position:relative;transform-origin:0 0}
    .map-img{display:block;max-width:none;height:auto;pointer-events:none;user-select:none; touch-action:none}
    .labels{position:absolute;left:0;top:0;right:0;bottom:0}

    /* 라벨: 가로 중앙, 아래쪽 기준 */
    .label{
      position:absolute;transform:translate(-50%,-100%);
      padding:.35em .5em;border-radius:10px;border:1px solid rgba(255,255,255,.15);
      background:rgba(17,20,28,.85);color:#fff;font-weight:800;white-space:nowrap;letter-spacing:.02em;
      box-shadow:0 4px 10px rgba(0,0,0,.35)
    }
    .label.normal{background:rgba(30,143,255,.9)}
    .label.extended{background:rgba(255,166,0,.95)}
    .label[data-size="25"]{font-size:10px}
    .label[data-size="50"]{font-size:12px}
    .label[data-size="70"]{font-size:14px}
    .label[data-size="100"]{font-size:16px}

    /* 탭 마커(잠깐 보이는 점) */
    .tap-dot{
      position:fixed; width:10px; height:10px; border-radius:50%;
      background:#fff; box-shadow:0 0 0 2px rgba(0,0,0,.4);
      transform:translate(-50%,-50%); pointer-events:none; z-index:9999; opacity:.9;
      animation: fade 0.6s ease-out forwards;
    }
    @keyframes fade{ to{ opacity:0; transform:translate(-50%,-50%) scale(0.8);} }

    .hint{font-size:12px;color:var(--muted)}
    .spacer{flex:1}
    input[type=file]{display:none}
    .file-label{cursor:pointer}

    .grid{display:grid;gap:8px}
    .grid.cols-2{grid-template-columns:1fr 1fr}

    .version-badge{
      position:fixed; right:10px; top:8px; z-index:1000;
      background:rgba(90,162,255,.15); border:1px solid var(--border); color:var(--text);
      padding:6px 10px; border-radius:10px; font-weight:800; font-size:13px; letter-spacing:.02em;
      backdrop-filter: blur(4px);
    }

    @media (min-width:760px){
      .toolbar{grid-template-columns:1.2fr .8fr}
    }
  </style>
</head>
<body>
  <div class="version-badge">V2.0</div>

  <div class="app">
    <div class="toolbar">
      <div class="panel grid">
        <div class="row">
          <label class="file-label btn" for="mapFile">지도 업로드/교체</label>
          <input id="mapFile" type="file" accept="image/*" />
          <button class="btn" id="resetView" title="지도를 화면에 맞춰 재정렬">보기 리셋</button>
          <div class="spacer"></div>
          <button class="btn" id="exportJson">JSON 내보내기</button>
          <label class="file-label btn" for="jsonFile">JSON 불러오기</label>
          <input id="jsonFile" type="file" accept="application/json" />
        </div>
        <div class="row">
          <div class="seg" role="group" aria-label="일반/연장 모드">
            <button id="modeNormal" aria-pressed="true">일반</button>
            <button id="modeExtended" aria-pressed="false">연장</button>
          </div>
          <div class="seg" role="group" aria-label="요일 선택" id="daySeg"></div>
          <div class="seg" role="group" aria-label="라벨 크기" id="sizeSeg"></div>
        </div>
        <div class="row">
          <div class="seg" role="group" aria-label="삭제 모드">
            <button id="delNone" aria-pressed="true">삭제 꺼짐</button>
            <button id="delSingle" aria-pressed="false">개별 삭제</button>
          </div>
          <button class="btn danger" id="delAll">모두 삭제</button>
          <span class="hint">지도를 탭하여 라벨을 추가하세요. (핀치로 확대/축소, 드래그로 이동)</span>
        </div>
      </div>

      <div class="panel grid">
        <div class="row"><strong>현재 상태</strong></div>
        <div class="row" id="status" aria-live="polite"></div>
        <div class="row hint">자동 저장 활성화: 앱을 닫거나 새로고침해도 라벨과 지도는 유지됩니다.</div>
      </div>
    </div>

    <div id="mapWrap" class="map-wrap">
      <div id="stage" class="map-stage">
        <img id="mapImg" class="map-img" alt="지도 이미지" />
        <div id="labels" class="labels"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = sel => document.querySelector(sel);
  const mapFile = $('#mapFile');
  const jsonFile = $('#jsonFile');
  const mapImg = $('#mapImg');
  const stage = $('#stage');
  const labelsLayer = $('#labels');
  const mapWrap = $('#mapWrap');
  const status = $('#status');

  const modeBtns = { normal: $('#modeNormal'), extended: $('#modeExtended') };
  const daySeg = $('#daySeg');
  const sizeSeg = $('#sizeSeg');
  const delBtns = { none: $('#delNone'), single: $('#delSingle') };
  const resetViewBtn = $('#resetView');
  const delAllBtn = $('#delAll');
  const exportBtn = $('#exportJson');

  const DAYS = ['월','화','수','목','금','토','일'];
  const SIZES = [25,50,70,100];

  let state = {
    mapDataUrl: '',         // (작으면 dataURL, 크면 '')
    labels: [],             // {xPct,yPct,text,size,kind}
    mode: 'normal',
    day: '월',
    size: 100,
    deleteMode: 'none',
    view: { scale: 1, tx: 0, ty: 0 }
  };

  /* ------------- IndexedDB (이미지 & 라벨 백업) ------------- */
  const DB_NAME = 'mapdb', STORE = 'kv';
  function idbOpen(){
    return new Promise((resolve, reject)=>{
      const r = indexedDB.open(DB_NAME, 1);
      r.onupgradeneeded = () => { r.result.createObjectStore(STORE, { keyPath: 'k' }); };
      r.onsuccess = () => resolve(r.result);
      r.onerror = () => reject(r.error);
    });
  }
  async function idbSet(key, value){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).put({k:key, v:value});
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject)=>{
      const tx = db.transaction(STORE, 'readonly');
      const req = tx.objectStore(STORE).get(key);
      req.onsuccess = () => resolve(req.result?.v ?? null);
      req.onerror = () => reject(req.error);
    });
  }

  /* ---------------- UI ---------------- */
  function buildDaySeg(){
    daySeg.innerHTML = '';
    for(const d of DAYS){
      const b = document.createElement('button');
      b.textContent = d;
      b.setAttribute('aria-pressed', d===state.day);
      b.addEventListener('click', () => { state.day = d; refreshSelections(); });
      daySeg.appendChild(b);
    }
  }
  function buildSizeSeg(){
    sizeSeg.innerHTML = '';
    for(const s of SIZES){
      const b = document.createElement('button');
      b.textContent = s+'%';
      b.setAttribute('aria-pressed', s===state.size);
      b.addEventListener('click', () => { state.size = s; refreshSelections(); });
      sizeSeg.appendChild(b);
    }
  }
  function refreshSelections(){
    modeBtns.normal.setAttribute('aria-pressed', state.mode==='normal');
    modeBtns.extended.setAttribute('aria-pressed', state.mode==='extended');
    [...daySeg.children].forEach(ch => ch.setAttribute('aria-pressed', ch.textContent===state.day));
    [...sizeSeg.children].forEach(ch => ch.setAttribute('aria-pressed', ch.textContent===state.size+'%'));
    delBtns.none.setAttribute('aria-pressed', state.deleteMode==='none');
    delBtns.single.setAttribute('aria-pressed', state.deleteMode==='single');
    updateStatus();
    saveAll();
  }
  function dayDisplay(){ return state.mode==='extended' ? ('6'+state.day) : state.day; }
  function updateStatus(msg){
    const base = `모드: ${state.mode==='normal'?'일반':'연장'} · 요일: ${dayDisplay()} · 크기: ${state.size}% · 라벨 ${state.labels.length}개`;
    status.textContent = msg ? `${base} · ${msg}` : base;
  }

  /* ---------------- Persistence (메타) ---------------- */
  const LS_KEY = 'map-labeler-v8';
  let userAdjustedView = false;
  let coverMinScale = 1;

  function saveLocal(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch(e){} }
  async function saveAll(){
    saveLocal();
    try{ await idbSet('labels', state.labels); }catch(e){}
  }
  function loadLocal(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(raw){
        const obj = JSON.parse(raw);
        if(obj && typeof obj==='object') state = Object.assign(state, obj);
      }
      if(state.mapDataUrl && state.mapDataUrl.startsWith('blob:')) state.mapDataUrl='';
    }catch(e){}
  }
  const debounce = (fn, ms=150) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); } };
  window.addEventListener('pagehide', saveAll);
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState!=='visible') saveAll(); });

  /* ---------------- Image processing ---------------- */
  async function fileToDataURL(file){
    return new Promise((resolve, reject)=>{
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsDataURL(file);
    });
  }
  async function downscaleDataURL(dataUrl, maxSide=1600, mime='image/jpeg', quality=0.85){
    return new Promise((resolve)=>{
      const img = new Image();
      img.onload = () => {
        let w = img.naturalWidth || img.width;
        let h = img.naturalHeight || img.height;
        const scale = Math.min(1, maxSide / Math.max(w, h));
        const sw = Math.max(1, Math.round(w * scale));
        const sh = Math.max(1, Math.round(h * scale));
        const c = document.createElement('canvas'); c.width = sw; c.height = sh;
        const ctx = c.getContext('2d'); ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, 0, 0, sw, sh);
        try{ resolve(c.toDataURL(mime, quality)); }catch(e){ resolve(dataUrl); }
      };
      img.onerror = () => resolve(dataUrl);
      img.src = dataUrl;
    });
  }
  async function loadAndPersistImage(file){
    const dataUrl = await fileToDataURL(file);
    const compact = await downscaleDataURL(dataUrl);
    setMap(compact);
    try { await idbSet('img', compact); } catch(e){}
    try {
      if (compact.length < 3_500_000) { state.mapDataUrl = compact; saveLocal(); }
      else { state.mapDataUrl = ''; saveLocal(); }
    } catch(e){}
  }

  /* ---------------- Map & Labels ---------------- */
  function setMap(dataUrl){
    state.mapDataUrl = dataUrl || state.mapDataUrl;
    mapImg.src = dataUrl;
    mapImg.onerror = () => { updateStatus('이미지 로딩 실패'); alert('이미지 로딩에 실패했습니다. 다른 파일로 시도해 주세요.'); };
    mapImg.onload  = () => { userAdjustedView=false; fitCover(); updateStatus('이미지 로딩 완료'); };
    saveLocal();
  }

  function renderLabels(){
    labelsLayer.innerHTML = '';
    for(const lab of state.labels){
      const el = document.createElement('div');
      el.className = 'label ' + (lab.kind==='extended'?'extended':'normal');
      el.dataset.size = lab.size;
      el.textContent = lab.text;
      el.style.left = lab.xPct + '%';
      el.style.top  = lab.yPct + '%';
      el.addEventListener('pointerdown', ev => ev.stopPropagation(), {passive:true});
      el.addEventListener('click', (ev) => {
        ev.stopPropagation();
        if(state.deleteMode==='single'){
          const idx = state.labels.indexOf(lab);
          if(idx>=0){ state.labels.splice(idx,1); renderLabels(); refreshSelections(); }
        }
      }, {passive:true});
      labelsLayer.appendChild(el);
    }
  }

  function showTapDot(x,y){
    const dot = document.createElement('div');
    dot.className = 'tap-dot';
    dot.style.left = x+'px'; dot.style.top = y+'px';
    document.body.appendChild(dot);
    setTimeout(()=>dot.remove(), 600);
  }

  function addLabelAt(clientX, clientY){
    if(!mapImg.src) return;
    if(state.deleteMode!=='none') return;
    showTapDot(clientX, clientY); // 시각 확인용
    const pt = clientToImagePercent(clientX, clientY);
    if(!pt) return;
    const text = state.mode==='extended' ? ('6'+state.day) : state.day;
    state.labels.push({ xPct: pt.xPct, yPct: pt.yPct, text, size: state.size, kind: state.mode });
    renderLabels();
    refreshSelections();
  }

  /* ✅ 좌표계: '변환된 stage의 실제 사각형' 기준 퍼센트 → 가장 견고한 방식
     - stageRect.width = naturalWidth * scale (transform 반영)
     - xPct = (clientX - stageRect.left) / stageRect.width * 100
  */
  function clientToImagePercent(clientX, clientY){
    const rect = stage.getBoundingClientRect(); // transform 반영
    if(rect.width<=0 || rect.height<=0) return null;
    const xPct = Math.max(0, Math.min(100, ((clientX - rect.left)  / rect.width  * 100)));
    const yPct = Math.max(0, Math.min(100, ((clientY - rect.top )  / rect.height * 100)));
    return { xPct, yPct };
  }

  /* ---------------- Pinch Zoom & Pan ---------------- */
  let pointers = new Map();

  function applyView(){
    clampViewToCover();
    const v = state.view;
    stage.style.transform = `translate(${v.tx}px, ${v.ty}px) scale(${v.scale})`;
  }
  function fitCover(){
    const w = mapImg.naturalWidth  || 0;
    const h = mapImg.naturalHeight || 0;
    if(!w || !h){ applyView(); return; }
    const wrap = mapWrap.getBoundingClientRect();
    coverMinScale = Math.max(wrap.width / w, wrap.height / h) || 1;
    const stageW = w * coverMinScale;
    const stageH = h * coverMinScale;
    const tx = (wrap.width  - stageW)/2;
    const ty = (wrap.height - stageH)/2;
    state.view = { scale: coverMinScale, tx, ty };
    applyView();
  }
  const saveViewDebounced = debounce(saveAll, 200);

  function screenToStage(x,y){
    const wrap = mapWrap.getBoundingClientRect();
    const v = state.view;
    return { x: (x - wrap.left - v.tx) / v.scale, y: (y - wrap.top - v.ty) / v.scale };
  }
  function clamp(v,min,max){return Math.max(min, Math.min(max, v));}

  function clampViewToCover(){
    const w = mapImg.naturalWidth || 0, h = mapImg.naturalHeight || 0; if(!w||!h) return;
    const wrap = mapWrap.getBoundingClientRect();
    const stageW = w * state.view.scale;
    const stageH = h * state.view.scale;
    const minTx = Math.min(0, wrap.width - stageW);
    const maxTx = 0;
    const minTy = Math.min(0, wrap.height - stageH);
    const maxTy = 0;
    state.view.tx = clamp(state.view.tx, minTx, maxTx);
    state.view.ty = clamp(state.view.ty, minTy, maxTy);
  }

  function zoomAround(factor, center){
    const v = state.view;
    const pre = screenToStage(center.x, center.y);
    v.scale = clamp(v.scale * factor, coverMinScale, 8);
    const post = screenToStage(center.x, center.y);
    v.tx += (post.x - pre.x) * v.scale;
    v.ty += (post.y - pre.y) * v.scale;
    userAdjustedView = true;
    applyView();
  }

  mapWrap.addEventListener('pointerdown', e => {
    mapWrap.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY, prevX:e.clientX, prevY:e.clientY, downX:e.clientX, downY:e.clientY, downT:performance.now(), type:e.pointerType});
  });

  mapWrap.addEventListener('pointermove', e => {
    if(!pointers.has(e.pointerId)) return;
    const p = pointers.get(e.pointerId);
    p.prevX = p.x; p.prevY = p.y; p.x = e.clientX; p.y = e.clientY;

    if(pointers.size===2){
      const ids = [...pointers.keys()];
      const a = pointers.get(ids[0]);
      const b = pointers.get(ids[1]);
      const distPrev = Math.hypot(a.prevX - b.prevX, a.prevY - b.prevY);
      const distCurr = Math.hypot(a.x - b.x, a.y - b.y);
      if(distPrev>0){
        const factor = distCurr / distPrev;
        const mid = { x: (a.x + b.x)/2, y: (a.y + b.y)/2 };
        zoomAround(factor, mid);
      }
    } else if(pointers.size===1){
      const dx = p.x - p.prevX; const dy = p.y - p.prevY;
      state.view.tx += dx; state.view.ty += dy; userAdjustedView = true; applyView(); saveViewDebounced();
    }
  }, {passive:true});

  mapWrap.addEventListener('pointerup', e => {
    const p = pointers.get(e.pointerId);
    if(p){
      const dt = performance.now() - p.downT;
      const move = Math.hypot(e.clientX - p.downX, e.clientY - p.downY);
      const isTap = dt < 250 && move < 6 && pointers.size===1;
      if(isTap && e.isPrimary){
        addLabelAt(e.clientX, e.clientY);
      }
    }
    pointers.delete(e.pointerId); saveAll();
  });
  mapWrap.addEventListener('pointercancel', e => { pointers.delete(e.pointerId); });

  mapWrap.addEventListener('dblclick', e => e.preventDefault(), {passive:false});
  mapWrap.addEventListener('wheel', e => {
    e.preventDefault();
    const factor = Math.pow(1.0015, -e.deltaY);
    zoomAround(factor, {x:e.clientX, y:e.clientY});
    saveViewDebounced();
  }, {passive:false});

  /* ---------------- Buttons / IO ---------------- */
  modeBtns.normal.addEventListener('click', ()=>{ state.mode='normal'; refreshSelections(); });
  modeBtns.extended.addEventListener('click', ()=>{ state.mode='extended'; refreshSelections(); });

  delBtns.none.addEventListener('click', ()=>{ state.deleteMode='none'; refreshSelections(); });
  delBtns.single.addEventListener('click', ()=>{ state.deleteMode='single'; refreshSelections(); });

  delAllBtn.addEventListener('click', ()=>{
    if(state.labels.length===0) return;
    const ok = confirm('전체 라벨을 삭제할까요? 이 작업은 되돌릴 수 없습니다.');
    if(ok){ state.labels = []; renderLabels(); refreshSelections(); }
  });

  resetViewBtn.addEventListener('click', ()=>{ userAdjustedView=false; fitCover(); saveAll(); });

  mapFile.addEventListener('change', async e => {
    const f = e.target.files && e.target.files[0]; if(!f) return;
    updateStatus('이미지 처리 중…');
    try{ await loadAndPersistImage(f); }
    catch(err){
      const r = new FileReader(); r.onload = ()=>setMap(r.result);
      r.onerror = ()=>{ updateStatus('파일 읽기 실패'); alert('파일을 읽는 중 오류가 발생했습니다.'); };
      r.readAsDataURL(f);
    }
  });

  exportBtn.addEventListener('click', ()=>{
    const data = JSON.stringify(state, null, 2);
    const blob = new Blob([data], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'map-labels.json';
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  });

  jsonFile.addEventListener('change', e => {
    const f = e.target.files && e.target.files[0]; if(!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const obj = JSON.parse(reader.result);
        if(!obj || !('labels' in obj)) throw new Error('잘못된 JSON');
        state = Object.assign(state, obj);
        if(state.mapDataUrl && state.mapDataUrl.startsWith('blob:')) state.mapDataUrl='';
        if(state.mapDataUrl) mapImg.src = state.mapDataUrl; else mapImg.removeAttribute('src');
        mapImg.onload = () => { userAdjustedView=false; fitCover(); updateStatus('JSON 로드 완료'); };
        renderLabels();
        refreshSelections();
      }catch(err){ alert('JSON을 읽는 중 오류: '+err.message); }
    };
    reader.readAsText(f);
  });

  /* ---------------- iOS 높이 보정 ---------------- */
  function setMapHeight(){
    const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.68;
    mapWrap.style.height = Math.max(240, Math.round(vh)) + 'px';
    if(mapImg.src && !userAdjustedView) fitCover();
  }
  window.addEventListener('resize', setMapHeight);
  window.addEventListener('orientationchange', setMapHeight);
  ['gesturestart','gesturechange','gestureend'].forEach(evt=>{
    document.addEventListener(evt, e => e.preventDefault(), {passive:false});
  });

  /* ---------------- Init ---------------- */
  buildDaySeg();
  buildSizeSeg();
  loadLocal();
  setMapHeight();

  (async () => {
    // 이미지 복구: 1) localStorage 2) IndexedDB
    if(state.mapDataUrl){
      setMap(state.mapDataUrl);
    } else {
      const fromIDB = await idbGet('img');
      if(fromIDB){ setMap(fromIDB); }
    }
    // 라벨 복구: 1) LS 2) IndexedDB
    if(!state.labels || state.labels.length===0){
      const idbLabels = await idbGet('labels');
      if(Array.isArray(idbLabels)) state.labels = idbLabels;
    }
    renderLabels();
    refreshSelections();
  })();
})();
</script>
</body>
</html>
